--
-- Offline Alife for non-EOC mode squads
-- Added by Dancher
-- Special thanks to offline alife of AMK, EOC and Anomaly!
--

local combats_per_level = 5
local day_distance = 15*15
local night_distance = 8*8
local add_rank_points = 20
local handicap_chance = 0.33
local victim_id_key = "victim_id"
local killer_id_key = "killer_id"

local update_timer
local updated_levels
local squads_to_levels
local loot_items

local last_killed_stalker

local rank_power = {
	novice = 10,
	trainee = 20,
	experienced = 30,
	professional = 40,
	veteran = 50,
	expert = 60,
	master = 70,
	legend = 80,
	-- monsters
	weak = 30,
	normal = 60,
	strong = 90
}

local function calculate_squad_power(squad)
	local power = 0
	for k in squad:squad_members() do
		local se_obj = alife_object(k.id)
		if (se_obj) then
			local rank_name = ranks.get_se_obj_rank_name(se_obj)
			power = power + rank_power[rank_name] or 0
		end
	end
	if (math.random() < handicap_chance) then
		power = power * math.random(3)
	end
	return power
end

-- from Anomaly 1.5.1.2
local squad_npcs
local function get_random_npc(squad)
	squad_npcs = squad_npcs or {}
	for k in squad:squad_members() do
		table.insert(squad_npcs, k.id)
	end
	local se_npc = alife_object(squad_npcs[math.random(#squad_npcs)])
	iempty_table(squad_npcs)
	return se_npc
end

local function process_combat(squad1, squad2, level_id, combat_distance)
	local distance = squad1.position:distance_to_sqr(squad2.position)
	if (distance > combat_distance) then
		return
	end
	
	local squad1_community = squad1:get_squad_community()
	local squad2_community = squad2:get_squad_community()
	local are_enemies = game_relations.is_factions_enemies(squad1_community, squad2_community)
	if (not are_enemies) then
		return
	end
	
	local killer_squad, victim_squad
	local has_tie = false
	local squad1_power = calculate_squad_power(squad1)
	local squad2_power = calculate_squad_power(squad2)
	
	if (squad1_power > squad2_power) then
		killer_squad = squad1
		victim_squad = squad2
		-- printf("### Dancher: %s(%s) kills %s(%s) (%s) ###", squad1:name(), squad1_power, squad2:name(), squad2_power, alife():level_name(level_id))
	elseif (squad1_power < squad2_power) then
		killer_squad = squad2
		victim_squad = squad1
		-- printf("### Dancher: %s(%s) kills %s(%s) (%s) ###", squad2:name(), squad2_power, squad1:name(), squad1_power, alife():level_name(level_id))
	elseif (squad1_power == squad2_power) then
		-- printf("### Dancher: %s(%s) tie %s(%s) (%s) ###", squad1:name(), squad1_power, squad2:name(), squad2_power, alife():level_name(level_id))
		has_tie = true
		return nil,has_tie
	end
	
	game_relations.drx_df_faction_npc_on_death(killer_squad:get_squad_community(), victim_squad:get_squad_community())
	
	local se_killer = get_random_npc(killer_squad)
	local se_victim = nil
	local is_stalker_squad = killer_squad:is_stalker()
	for k in victim_squad:squad_members() do
		se_killer = math.random(2) == 1 and se_killer or get_random_npc(killer_squad)
		se_victim = alife_object(k.id)
		if (se_victim) then
			se_victim:on_death(se_killer)
			if (is_stalker_squad) then
				se_killer:set_rank(se_killer:rank() + add_rank_points)
			end
		end
		if (se_victim and loot_items[se_victim.id] and loot_items[se_killer.id]) then
			local victim_items = loot_items[se_victim.id]
			for i=1,#victim_items do
				local victim_item = alife_object(victim_items[i])
				table.remove(loot_items[se_victim.id], victim_item.id)
				
				local killer_item = alife():create(victim_item:section_name(), se_killer.position, se_killer.m_level_vertex_id, se_killer.m_game_vertex_id, se_killer.id)
				table.insert(loot_items[se_killer.id], killer_item.id)
				
				safe_release_manager.release(victim_item)
				-- printf("### Dancher: loot relocated!")
			end
		end
	end
	
	if (se_victim and IsStalker(se_victim)) then
		if (last_killed_stalker == nil) then
			last_killed_stalker = {}
		end
		last_killed_stalker[victim_id_key] = se_victim.id
		last_killed_stalker[killer_id_key] = se_killer.id
	end
	
	return victim_squad,has_tie
end

local function process_squads_combat(squads)
	if (#squads == 0) then
		return
	end

	local combat_distance = xr_conditions.is_day() and day_distance or night_distance
	local level_id = simulation_objects.get_level_id(squads[1])
	local squads_count = #squads
	local combats_count = 0
	
	for i=1,squads_count do
		if (combats_count == combats_per_level) then
			break
		end
		
		local squad1 = squads[i]
		
		if (squad1) then
			for j=1,squads_count do
				if (combats_count == combats_per_level) then
					break
				end
				
				local squad2 = squads[j]
				
				if (squad2 and squad1.id ~= squad2.id and 
					simulation_objects.is_on_the_same_level(squad1, squad2)) 
				then
					local victim_squad,has_tie = process_combat(squad1,squad2,level_id,combat_distance)
					
					if (victim_squad) then
						combats_count = combats_count + 1
						if (victim_squad.id == squad1.id) then
							squads[i] = nil
							break
						elseif (victim_squad.id == squad2.id) then
							squads[j] = nil
						end
					elseif (has_tie) then
						combats_count = combats_count + 1
					end
				end
			end
		end
	end
end

local function is_squad_valid(squad)
	if (not squad:alive() or 
		get_object_story_id(squad.id) or 
		xrs_kill_wounded.hostage_list[squad:commander_id()]) 
	then
		return false
	end
	
	local task_info = task_manager.get_task_manager().task_info
	for k in squad:squad_members() do
		if (axr_task_manager.bounties_by_id) then
			for _,npc_id in pairs(axr_task_manager.bounties_by_id) do
				if (npc_id == k.id) then
					return false
				end
			end
		end
		local se_obj = alife_object(k.id)
		for _,task in pairs(task_info) do
			local giver_id = task.task_giver_id
			if (se_obj and giver_id and (giver_id == se_obj.group_id or giver_id == se_obj.id)) then
				return false
			end
		end
    end
	
	return true
end

local function actor_on_slicing_update()
	local tg = time_global()
	
	if (tg < update_timer) then
		return
	end
	
	update_timer = tg + math.random(10000,15000)
	
	if (squads_to_levels == nil) then
		squads_to_levels = {}
		
		for _,squad in pairs(SIMBOARD.squads) do
			if (squad and not squad.online and squad.first_update and is_squad_valid(squad)) then
				local level_id = simulation_objects.get_level_id(squad)
				if (squads_to_levels[level_id] == nil) then
					squads_to_levels[level_id] = {}
				end
				table.insert(squads_to_levels[level_id], squad)
				if not squad:is_monster() then
					for k in squad:squad_members() do
						loot_items[k.id] = {}
					end
				end
			end
		end
		
		for _,squads in ipairs(squads_to_levels) do
			utils.shuffle_table(squads)
		end
		utils.shuffle_table(squads_to_levels)
		
		for i=1,65534 do
			local se_obj = alife_object(i)
			if (se_obj and se_obj.parent_id and loot_items[se_obj.parent_id]) then
				table.insert(loot_items[se_obj.parent_id], se_obj.id)
				-- printf("### Dancher: loot added (%s) ###", tostring(se_obj.id))
			end
		end
		
		gc.collect("offline squads combat init")
		return
	end
	
	local level_to_update
	
	for id,_ in pairs(squads_to_levels) do
		if (updated_levels[id] == nil) then
			level_to_update = id
			break
		end
	end
	
	if (level_to_update == nil) then
		empty_table(updated_levels)
		-- printf("### Dancher: restart offline squads combat ###")
		return
	end
	
	local squads_to_combat = squads_to_levels[level_to_update]
	process_squads_combat(squads_to_combat)
	-- printf("### Dancher: process offline squads combat ###")
	
	updated_levels[level_to_update] = true
end

local function actor_on_first_update()
	if (IsEocMode()) then
		UnregisterScriptCallback("actor_on_first_update",actor_on_first_update)
		return
	end
	
	loot_items = {}
	updated_levels = {}
	update_timer = time_global() + 1000
	RegisterScriptCallback("actor_on_slicing_update",actor_on_slicing_update)
end

function on_game_start()
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
end

function is_enabled()
	return IsEocMode() == false
end

function pop_last_killed_stalker_data()
	local data = last_killed_stalker
	last_killed_stalker = nil
	return data
end
