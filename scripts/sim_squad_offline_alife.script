--
-- Offline Alife for squads
-- Added by Dancher
-- Special thanks to AMK Offline Alife and EOC mod!
--

local combat_distance = 30*30

local update_timer
local updated_levels = {}
local squads_to_levels
local squads_to_combat

local function process_combat(squad1, squad2)
	local squad1_community = squad1:get_squad_community()
	local squad2_community = squad2:get_squad_community()
	local are_enemies = game_relations.is_factions_enemies(squad1_community, squad2_community)
	
	if (not are_enemies) then
		return
	end
	
	local distance = squad1.position:distance_to_sqr(squad2.position)
	
	if (distance > combat_distance or
		(squad1:npc_count() == 0 or squad2:npc_count() == 0) or
		(get_object_story_id(squad1.id) or get_object_story_id(squad2.id)) or
		(squad1:alive() == false or squad2:alive() == false)) then
		return
	end
	
	local chance = math.random()
	if (chance < 0.1) then
		game_relations.drx_df_faction_npc_on_death(squad1:get_squad_community(), squad2:get_squad_community())
		for k in squad2:squad_members() do
			local se_obj = alife_object(k.id)
			if (se_obj) then
				se_obj.health = 0
			end
		end
		printf("### Dancher: %s has killed by %s ###", squad2:name(), squad1:name())
		return
	end
	
	chance = math.random()
	if (chance < 0.1) then
		game_relations.drx_df_faction_npc_on_death(squad2:get_squad_community(), squad1:get_squad_community())
		for k in squad1:squad_members() do
			local se_obj = alife_object(k.id)
			if (se_obj) then
				se_obj.health = 0
			end
		end
		printf("### Dancher: %s has killed by %s ###", squad2:name(), squad1:name())
	end
end

local function process_squads_combat()
	local squads_count = #squads_to_combat
	
	for i=1,squads_count do
		local squad1 = squads_to_combat[i]
		
		for j=1,squads_count do
			local squad2 = squads_to_combat[j]
			
			if (squad1.id ~= squad2.id and simulation_objects.is_on_the_same_level(squad1, squad2)) then
				process_combat(squad1,squad2)
			end
		end
	end
end

local function actor_on_first_update()
	update_timer = time_global() + 1000
end

local function actor_on_slicing_update()
	local tg = time_global()
	
	if (tg < update_timer) then
		return
	end
	
	update_timer = tg + math.random(5000,10000)
	
	if (squads_to_levels == nil) then
		squads_to_levels = {}
		for _,squad in pairs(SIMBOARD.squads) do
			if (squad and not squad.online and squad.first_update) then
				local level_id = simulation_objects.get_level_id(squad)
				if (squads_to_levels[level_id] == nil) then
					squads_to_levels[level_id] = {}
				end
				table.insert(squads_to_levels[level_id], squad)
			end
		end
	end
	
	local level_to_update
	
	for id,_ in pairs(squads_to_levels) do
		if (updated_levels[id] == nil) then
			level_to_update = id
			break
		end
	end
	
	if (level_to_update == nil) then
		empty_table(updated_levels)
		printf("### Dancher: restart offline squads combat ###")
		return
	end
	
	squads_to_combat = squads_to_levels[level_to_update]
	
	if (#squads_to_combat > 0) then
		printf("### Dancher: process offline squads combat on %s ###", level_to_update)
		process_squads_combat()
	end
	
	squads_to_combat = nil
	updated_levels[level_to_update] = true
end

function on_game_start()
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
	RegisterScriptCallback("actor_on_slicing_update",actor_on_slicing_update)
end
